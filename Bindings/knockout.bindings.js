// Generated by CoffeeScript 1.3.3
(function() {
  var _setDate, _updateAutocompleteFields,
    __hasProp = {}.hasOwnProperty;

  _updateAutocompleteFields = function(viewModel, fields, item, isResetOnNull) {
    var field, _results;
    _results = [];
    for (field in fields) {
      if (!__hasProp.call(fields, field)) continue;
      if (item && item.data) {
        _results.push(viewModel[fields[field]](item.data[field]));
      } else if (isResetOnNull) {
        _results.push(viewModel[fields[field]](null));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  ko.bindingHandlers.autocomplete = {
    init: function(element, valueAccessor, allBindingsAccessor, viewModel) {
      var opts;
      opts = allBindingsAccessor().autocompleteOpts;
      return $(element).autocomplete({
        source: function(request, response) {
          return $.ajax({
            url: opts.url,
            data: {
              Term: $(element).val()
            },
            dataType: "json",
            success: function(data) {
              return response(data.map(function(d) {
                return {
                  data: d,
                  label: d.FullName ? d.FullName : d.Name,
                  value: d.Name,
                  key: d.Name
                };
              }));
            },
            minLength: 2
          });
        },
        select: function(event, ui) {
          console.log("select " + ui.item);
          valueAccessor()(ui.item.value);
          return _updateAutocompleteFields(viewModel, opts.fields, ui.item, opts.resetRelatedFieldsOnNull);
        },
        change: function(event, ui) {
          console.log("change " + ui.item);
          valueAccessor()($(element).val());
          return _updateAutocompleteFields(viewModel, opts.fields, ui.item, opts.resetRelatedFieldsOnNull);
        }
      });
    },
    update: function(element, valueAccessor, allBindingsAccessor) {
      var opts, value;
      opts = allBindingsAccessor().autocompleteOpts;
      value = ko.utils.unwrapObservable(valueAccessor());
      console.log("update " + value);
      if ($(element).val() !== value) {
        return $(element).val(value);
      }
    }
  };

  ko.bindingHandlers.datetime = {
    init: function(element, valueAccessor) {
      var dmaxRule, dminRule, maxDate, minDate;
      if (valueAccessor().extend && valueAccessor().extend().rules) {
        dminRule = valueAccessor().extend().rules().filter(function(f) {
          return f.rule === "min";
        })[0];
        if (dminRule) {
          minDate = moment(dminRule.params).toDate();
        }
        dmaxRule = valueAccessor().extend().rules().filter(function(f) {
          return f.rule === "max";
        })[0];
        if (dmaxRule) {
          maxDate = moment(dmaxRule.params).toDate();
        }
      }
      $(element).datepicker({
        minDate: minDate,
        maxDate: maxDate,
        beforeShow: function(el) {
          if ($(el).attr('readonly')) {
            return false;
          } else {
            return true;
          }
        }
      });
      ko.utils.registerEventHandler(element, "change", function() {
        var date, observable;
        observable = valueAccessor();
        date = $(element).datepicker("getDate");
        return observable(date);
      });
      return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
        return $(element).datepicker("destroy");
      });
    },
    update: function(element, valueAccessor) {
      var value;
      value = ko.utils.unwrapObservable(valueAccessor());
      $(element).datepicker("setDate", value ? value : null);
      return valueAccessor()($(element).datepicker("getDate"));
    }
  };

  _setDate = function(element, date, format) {
    if (format == null) {
      format = "DD MMMM YYYY";
    }
    return $(element).text(date ? moment(date).format(format) : "");
  };

  ko.bindingHandlers.displaydate = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var format, option, valAccessor;
      option = allBindingsAccessor().ddateOpts;
      if (option) {
        format = option.format;
      }
      valAccessor = valueAccessor();
      _setDate(element, ko.utils.unwrapObservable(valAccessor), format);
      return valAccessor.subscribe(function(newValue) {
        return _setDate(element, newValue, format);
      });
    }
  };

  ko.bindingHandlers.validationCss = {
    init: function(element, valueAccessor) {
      var f, observable, _setClass;
      observable = valueAccessor();
      f = false;
      _setClass = function(val) {
        if (!val) {
          return $(element).addClass("error");
        } else {
          return $(element).removeClass("error");
        }
      };
      observable.isModified.subscribe(function() {
        f = true;
        return _setClass(observable.isValid());
      });
      observable.isValid.subscribe(function(val) {
        if (f) {
          return _setClass(val);
        }
      });
      return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
        console.log("dispose");
        return $(element).removeClass("error");
      });
    }
  };

  ko.bindingHandlers.validation = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var all, prop, v, validation, _i, _len, _results;
      all = allBindingsAccessor();
      prop = all.value ? all.value : all.autocomplete ? all.autocomplete : all.datetime ? all.datetime : void 0;
      if (prop) {
        validation = valueAccessor();
        if (!Array.isArray(validation)) {
          validation = [validation];
        }
        _results = [];
        for (_i = 0, _len = validation.length; _i < _len; _i++) {
          v = validation[_i];
          _results.push(prop.extend(v));
        }
        return _results;
      }
    }
  };

  /*
  ko.bindingHandlers.customError =
  
    init: (element, valueAccessor, allBindingsAccessor, viewModel) ->
      if viewModel.customErrors
        observable = valueAccessor()
        prop = observable()
        viewModel.customErrors.subscribe (val) ->
          if !$(element).text()
            err = viewModel.customErrors().filter((f) -> f.field == prop)[0]
            if err
              $(element).text err
  */


  ko.bindingHandlers.link = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var opts;
      opts = allBindingsAccessor().linkOpts;
      return $(element).click(function(event) {
        var value;
        event.preventDefault();
        value = ko.utils.unwrapObservable(valueAccessor());
        if (value) {
          window.location = "/" + opts.resource + "/" + value;
        }
        return false;
      });
    }
  };

}).call(this);
