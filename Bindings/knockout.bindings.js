// Generated by CoffeeScript 1.3.3
(function() {
  var _filterFields, _setDate, _updateAutocompleteFields,
    __hasProp = {}.hasOwnProperty;

  _updateAutocompleteFields = function(viewModel, fields, item, isResetOnNull) {
    var field, _results;
    _results = [];
    for (field in fields) {
      if (!__hasProp.call(fields, field)) continue;
      if (item && item.data) {
        _results.push(viewModel[fields[field]](item.data[field]));
      } else if (isResetOnNull) {
        _results.push(viewModel[fields[field]](null));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _filterFields = function(viewModel, fields) {
    var data, field;
    data = {};
    for (field in fields) {
      if (!__hasProp.call(fields, field)) continue;
      data[field] = viewModel[fields[field]]();
    }
    return data;
  };

  ko.bindingHandlers.autocomplete = {
    init: function(element, valueAccessor, allBindingsAccessor, viewModel) {
      var opts;
      opts = allBindingsAccessor().autocompleteOpts;
      if (opts.allowNotInList === void 0) {
        opts.allowNotInList = true;
      }
      return $(element).autocomplete({
        source: function(request, response) {
          var data;
          data = {
            Term: $(element).val()
          };
          if (opts.filterFields) {
            data = $.extend(false, data, _filterFields(viewModel, opts.filterFields));
          }
          return $.ajax({
            url: opts.url,
            data: data,
            dataType: "json",
            success: function(data) {
              var m;
              m = data.map(function(d) {
                return {
                  data: d,
                  label: d.FullName ? d.FullName : d.Name,
                  value: d.Name,
                  key: d.Id
                };
              });
              return response(m);
            },
            minLength: 2
          });
        },
        select: function(event, ui) {
          console.log("select " + ui.item);
          valueAccessor()(ui.item.value);
          return _updateAutocompleteFields(viewModel, opts.fields, ui.item, opts.resetRelatedFieldsOnNull);
        },
        change: function(event, ui) {
          var observable;
          console.log("change " + ui.item);
          observable = valueAccessor();
          observable((opts.allowNotInList || ui.item ? $(element).val() : null));
          $(element).val(observable());
          return _updateAutocompleteFields(viewModel, opts.fields, ui.item, opts.resetRelatedFieldsOnNull);
        }
      });
    },
    update: function(element, valueAccessor, allBindingsAccessor) {
      var opts, value;
      opts = allBindingsAccessor().autocompleteOpts;
      value = ko.utils.unwrapObservable(valueAccessor());
      console.log("update " + value);
      if ($(element).val() !== value) {
        return $(element).val(value);
      }
    }
  };

  ko.bindingHandlers.datetime = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var dateFormat, dmaxRule, dminRule, maxDate, minDate, opts;
      if (valueAccessor().extend && valueAccessor().extend().rules) {
        dminRule = valueAccessor().extend().rules().filter(function(f) {
          return f.rule === "min";
        })[0];
        if (dminRule) {
          minDate = moment(dminRule.params).toDate();
        }
        dmaxRule = valueAccessor().extend().rules().filter(function(f) {
          return f.rule === "max";
        })[0];
        if (dmaxRule) {
          maxDate = moment(dmaxRule.params).toDate();
        }
      }
      opts = allBindingsAccessor().datetimeOpts;
      dateFormat = opts && opts.dateFormat ? opts.dateFormat : "dd.mm.yy";
      $(element).datepicker({
        minDate: minDate,
        maxDate: maxDate,
        dateFormat: dateFormat,
        beforeShow: function(el) {
          if ($(el).attr('readonly')) {
            return false;
          } else {
            return true;
          }
        }
      });
      ko.utils.registerEventHandler(element, "change", function() {
        var date, observable;
        observable = valueAccessor();
        date = $(element).datepicker("getDate");
        return observable(date);
      });
      return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
        return $(element).datepicker("destroy");
      });
    },
    update: function(element, valueAccessor) {
      var value;
      value = ko.utils.unwrapObservable(valueAccessor());
      $(element).datepicker("setDate", value ? value : null);
      return valueAccessor()($(element).datepicker("getDate"));
    }
  };

  _setDate = function(element, date, format) {
    if (format == null) {
      format = "DD MMMM YYYY";
    }
    return $(element).text(date ? moment(date).format(format) : "");
  };

  ko.bindingHandlers.displaydate = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var format, option, valAccessor;
      option = allBindingsAccessor().ddateOpts;
      if (option) {
        format = option.format;
      }
      valAccessor = valueAccessor();
      _setDate(element, ko.utils.unwrapObservable(valAccessor), format);
      return valAccessor.subscribe(function(newValue) {
        return _setDate(element, newValue, format);
      });
    }
  };

  ko.bindingHandlers.validationCss = {
    init: function(element, valueAccessor) {
      var f, observable, _setClass;
      observable = valueAccessor();
      f = false;
      _setClass = function(val) {
        if (!val) {
          return $(element).addClass("error");
        } else {
          return $(element).removeClass("error");
        }
      };
      observable.isModified.subscribe(function() {
        f = true;
        return _setClass(observable.isValid());
      });
      observable.isValid.subscribe(function(val) {
        if (f) {
          return _setClass(val);
        }
      });
      return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
        console.log("dispose");
        return $(element).removeClass("error");
      });
    }
  };

  ko.bindingHandlers.validation = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var all, prop, v, validation, _i, _len, _results;
      all = allBindingsAccessor();
      prop = all.value ? all.value : all.autocomplete ? all.autocomplete : all.datetime ? all.datetime : void 0;
      if (prop) {
        validation = valueAccessor();
        if (!Array.isArray(validation)) {
          validation = [validation];
        }
        _results = [];
        for (_i = 0, _len = validation.length; _i < _len; _i++) {
          v = validation[_i];
          _results.push(prop.extend(v));
        }
        return _results;
      }
    }
  };

  ko.bindingHandlers.link = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var opts;
      opts = allBindingsAccessor().linkOpts;
      return $(element).click(function(event) {
        var value;
        event.preventDefault();
        value = ko.utils.unwrapObservable(valueAccessor());
        if (value) {
          window.location = "/" + opts.resource + "/" + value;
        }
        return false;
      });
    }
  };

  ko.bindingHandlers.val = {
    init: function(element, valueAccessor, allBindingsAccessor) {
      var interceptor, underlyingObservable, valOpts,
        _this = this;
      underlyingObservable = valueAccessor();
      valOpts = allBindingsAccessor().valOpts;
      $(element).inputmask('decimal', {
        radixPoint: ',',
        autoUnmask: true,
        clearMaskOnLostFocus: true
      });
      interceptor = ko.computed({
        read: function() {
          var val;
          val = ko.isObservable(underlyingObservable) ? underlyingObservable() : underlyingObservable;
          if (val) {
            val = val.toString();
            return val.replace(".", ",");
          }
        },
        write: function(val) {
          var fmtVal;
          fmtVal = parseFloat(val.replace(",", "."));
          return underlyingObservable(fmtVal);
        },
        deferEvaluation: true
      });
      return ko.applyBindingsToNode(element, {
        value: interceptor
      });
    }
  };

}).call(this);
